var documenterSearchIndex = {"docs":
[{"location":"uai_file_formats/#UAI-file-formats","page":"UAI file formats","title":"UAI file formats","text":"","category":"section"},{"location":"uai_file_formats/","page":"UAI file formats","title":"UAI file formats","text":"This document defines the following file formats:","category":"page"},{"location":"uai_file_formats/","page":"UAI file formats","title":"UAI file formats","text":"Model file format.\nEvidence file format.\nResults file format.","category":"page"},{"location":"uai_file_formats/#Model-file-format","page":"UAI file formats","title":"Model file format","text":"","category":"section"},{"location":"uai_file_formats/","page":"UAI file formats","title":"UAI file formats","text":"We use the simple text file format specified below to describe problem instances (Markov networks). The format is a generalization of the Ergo file format initially developed by Noetic Systems Inc. for their Ergo software. We use the .uai suffix for the evaluation benchmark network files.","category":"page"},{"location":"uai_file_formats/#Structure","page":"UAI file formats","title":"Structure","text":"","category":"section"},{"location":"uai_file_formats/","page":"UAI file formats","title":"UAI file formats","text":"A file in the UAI format consists of the following two parts, in that order:","category":"page"},{"location":"uai_file_formats/","page":"UAI file formats","title":"UAI file formats","text":"<Preamble>\n\n<Function tables>","category":"page"},{"location":"uai_file_formats/","page":"UAI file formats","title":"UAI file formats","text":"The contents of each section (denoted <...> above) are described in the following:","category":"page"},{"location":"uai_file_formats/#Preamble","page":"UAI file formats","title":"Preamble","text":"","category":"section"},{"location":"uai_file_formats/","page":"UAI file formats","title":"UAI file formats","text":"Our description of the format will follow a simple Markov network with three variables and two functions. A sample preamble for such a network is:","category":"page"},{"location":"uai_file_formats/","page":"UAI file formats","title":"UAI file formats","text":"MARKOV\n3\n2 2 3\n2\n2 0 1\n2 1 2","category":"page"},{"location":"uai_file_formats/","page":"UAI file formats","title":"UAI file formats","text":"The preamble starts with one line denoting the type of network. Generally, this can be either BAYES (if the network is a Bayesian network) or MARKOV (in case of a Markov network). However, note that this year all networks will be given in a Markov networks (i.e. Bayesian networks will be moralized).","category":"page"},{"location":"uai_file_formats/","page":"UAI file formats","title":"UAI file formats","text":"The second line contains the number of variables. The next line specifies the cardinalities of each variable, one at a time, separated by a whitespace (note that this implies an order on the variables which will be used throughout the file). The fourth line contains only one integer, denoting the number of cliques in the problem. Then, one clique per line, the scope of each clique is given as follows: The first integer in each line specifies the number of variables in the clique, followed by the actual indexes of the variables. The order of this list is not restricted. Note that the ordering of variables within a factor will follow the order provided here.","category":"page"},{"location":"uai_file_formats/","page":"UAI file formats","title":"UAI file formats","text":"Referring to the example above, the first line denotes the Markov network, the second line tells us the problem consists of three variables, let's refer to them as X, Y, and Z. Their cardinalities are 2, 2, and 3 respectively (from the third line). Line four specifies that there are 2 cliques. The first clique is X,Y, while the second clique is Y,Z. Note that variables are indexed starting with 0.","category":"page"},{"location":"uai_file_formats/#Function-tables","page":"UAI file formats","title":"Function tables","text":"","category":"section"},{"location":"uai_file_formats/","page":"UAI file formats","title":"UAI file formats","text":"In this section each factor is specified by giving its full table (i.e, specifying value for each assignment). The order of the factor is identical to the one in which they were introduced in the preamble, the first variable have the role of the 'most significant' digit. For each factor table, first the number of entries is given (this should be equal to the product of the domain sizes of the variables in the scope). Then, one by one, separated by whitespace, the values for each assignment to the variables in the function's scope are enumerated. Tuples are implicitly assumed in ascending order, with the last variable in the scope as the 'least significant'. To illustrate, we continue with our Markov network example from above, let's assume the following conditional probability tables:","category":"page"},{"location":"uai_file_formats/","page":"UAI file formats","title":"UAI file formats","text":"X     P(X)\n0     0.436\n1     0.564\n\nX Y   P(Y,X)\n0 0   0.128\n0 1   0.872\n1 0   0.920\n1 1   0.080\n\nY Z   P(Z,Y)\n0 0   0.210\n0 1   0.333\n0 2   0.457\n1 0   0.811\n1 1   0.000\n1 2   0.189","category":"page"},{"location":"uai_file_formats/","page":"UAI file formats","title":"UAI file formats","text":"The corresponding function tables in the file would then look like this:","category":"page"},{"location":"uai_file_formats/","page":"UAI file formats","title":"UAI file formats","text":"2\n0.436 0.564\n\n4\n0.128 0.872\n0.920 0.080\n\n6\n0.210 0.333 0.457\n0.811 0.000 0.189","category":"page"},{"location":"uai_file_formats/","page":"UAI file formats","title":"UAI file formats","text":"(Note that line breaks and empty lines are effectively just a whitespace, exactly like plain spaces \" \". They are used here to improve readability.)","category":"page"},{"location":"uai_file_formats/#Summary","page":"UAI file formats","title":"Summary","text":"","category":"section"},{"location":"uai_file_formats/","page":"UAI file formats","title":"UAI file formats","text":"To sum up, a problem file consists of 2 sections: the preamble and the full the function tables, the names and the labels. For our Markov network example above, the full file will look like:","category":"page"},{"location":"uai_file_formats/","page":"UAI file formats","title":"UAI file formats","text":"MARKOV\n3\n2 2 3\n3\n1 0\n2 0 1\n2 1 2\n\n2\n0.436 0.564\n\n4\n0.128 0.872\n0.920 0.080\n\n6\n0.210 0.333 0.457\n0.811 0.000 0.189","category":"page"},{"location":"uai_file_formats/#Evidence-file-format","page":"UAI file formats","title":"Evidence file format","text":"","category":"section"},{"location":"uai_file_formats/","page":"UAI file formats","title":"UAI file formats","text":"Evidence is specified in a separate file. This file has the same name as the original network file but with an added .evid suffix. For instance, problem.uai will have evidence in problem.uai.evid. The file starts with a line specifying the number of evidences samples. The evidence in each sample, will be written in a new line. Each line will begin with the number of observed variables in the sample, followed by pairs of variable and its observed value. The indexes correspond to the ones implied by the original problem file. If, for our above example, we want to provide a single sample where the variable Y has been observed as having its first value and Z with its second value, the file example.uai.evid would contain the following:","category":"page"},{"location":"uai_file_formats/","page":"UAI file formats","title":"UAI file formats","text":"1\n2 1 0 2 1","category":"page"},{"location":"uai_file_formats/#Results-file-format","page":"UAI file formats","title":"Results file format","text":"","category":"section"},{"location":"uai_file_formats/","page":"UAI file formats","title":"UAI file formats","text":"The first line must contain only the task solved: PR|MPE|MAR|BEL. The rest of the file will contain the solution for the task. Solvers can write more then one solution by writing -BEGIN- at the head of the new solution. We will only consider the last solution in the file. In the example below the task we choose is PR. We have two solutions. The format of the <SOLUTION> part will be described below.","category":"page"},{"location":"uai_file_formats/","page":"UAI file formats","title":"UAI file formats","text":"PR\n<SOLUTION>\n-BEGIN-\n<SOLUTION>","category":"page"},{"location":"uai_file_formats/","page":"UAI file formats","title":"UAI file formats","text":"The first line in each solution will contain the number of evidence samples. This will be the number of lines (not include this line) in the solution part. Hence each line from here will contain the solution with a different sample of evidence - ordered as in the evidence file. If there is no evidence (the first line of the evidence file is 0), the output should include the results for the empty evidence scenario. This is regarded as a single-evidence case - one with the empty evidence.","category":"page"},{"location":"uai_file_formats/","page":"UAI file formats","title":"UAI file formats","text":"Solvers that can bound their estimation are encouraged to specify if their solution is lower or upper bound. Doing so by adding at the end of the solution the letters L(for lower bound) or U (for upper bound).","category":"page"},{"location":"uai_file_formats/","page":"UAI file formats","title":"UAI file formats","text":"The line format is as follows (according to the task):","category":"page"},{"location":"uai_file_formats/","page":"UAI file formats","title":"UAI file formats","text":"Partition function, PR: Line with the value of the log10 of the partition function. For example, an approximation log10 Pr(e) = -0.2008 which is known to be an upper bound may have a solution line:\n-0.2008 U\nMost probable explanation, MPE: A space separated line that includes:\nthe number n of model variables, and\nthe MPE instantiation, a list of value indices for all n variables.\nFor example, an input model with 3 binary variables may have a solution line:\n3 0 1 0\nMarginals, MAR: A space separated line that includes:\nThe number of variables in the model.\nA list of marginal approximations of all the variables. For each variable its cardinality is first stated, then the probability of each state is stated. The order of the variables is the same as in the model, all data is space separated.\nFor example, a model with 3 variables, with cardinalities of 2, 2, 3 respectively. The solution might look like this:\n3 2 0.1 0.9 2 0.3 0.7 3 0.2 0.2 0.6\nBeliefs, BEL: A space separated line that includes:\nThe number n of model cliques, and\nA list of belief approximations for all n cliques. Each marginal approximation is specified by a list, starting with the number of entries of the factor, followed by the approximation Pr(x|e) for each value of x (where is a vector of the clique variables).\nFor example, if an input model has 2 cliques the first with 2 binary variable and the second with 3.The solution line may look like:\n2 4 0.25 0.25 0.4 0.1 8 0.1 0.05 0.05 0.2 0.1 0.01 0.04 0.45\nThe order of the entries is as in the model description.","category":"page"},{"location":"uai_file_formats/","page":"UAI file formats","title":"UAI file formats","text":"Here is a complete example for a solution for the MPE task. The evidence file contains one evidence samples.","category":"page"},{"location":"uai_file_formats/","page":"UAI file formats","title":"UAI file formats","text":"MPE\n1\n4 0 2 0 4\n-BEGIN-\n1\n4 0 2 0 4","category":"page"},{"location":"uai_file_formats/","page":"UAI file formats","title":"UAI file formats","text":"If a solver does not produce a solution by the given time, it would be considered as having failed on the instance. This will be treated as equivalent to a naive solution (e.g. bit-wise singleton clique maximum for a MAP problem).","category":"page"},{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"pace_file_formats/#PACE-file-format","page":"PACE file formats","title":"PACE file format","text":"","category":"section"},{"location":"pace_file_formats/","page":"PACE file formats","title":"PACE file formats","text":"This document defines the following file formats:","category":"page"},{"location":"pace_file_formats/","page":"PACE file formats","title":"PACE file formats","text":"Graph format.\nTree decomposition format.","category":"page"},{"location":"pace_file_formats/#Graph-format","page":"PACE file formats","title":"Graph format","text":"","category":"section"},{"location":"pace_file_formats/","page":"PACE file formats","title":"PACE file formats","text":"We describe the file format .gr, which is similar to the format used by DIMACS challenges.","category":"page"},{"location":"pace_file_formats/","page":"PACE file formats","title":"PACE file formats","text":"Lines are separated by the character ‘\\n’. Each line that starts with the character c is considered to be a comment line. The first non-comment line must be a line starting with p followed by the problem descriptor tw and the number of vertices n and edges m (separated by a single space each time). No other line may start with p. Every other line indicates an edge, and must consist of two decimal integers from 1 to n separated by a space; moreover, graphs are considered undirected (though they may contain isolated vertices, multiple edges, and loops). For example, a path with four edges can be defined as follows:","category":"page"},{"location":"pace_file_formats/","page":"PACE file formats","title":"PACE file formats","text":"c This file describes a path with five vertices and four edges.\np tw 5 4\n1 2\n2 3\nc we are half-way done with the instance definition.\n3 4\n4 5","category":"page"},{"location":"pace_file_formats/#Tree-decomposition-format","page":"PACE file formats","title":"Tree decomposition format","text":"","category":"section"},{"location":"pace_file_formats/","page":"PACE file formats","title":"PACE file formats","text":"Recall the definition of a tree decomposition of a graph G: It is a tree T such that every vertex x in V(T) has an associated bag B(x) that is a subset of V(G). Every edge e in E(G) must be a subset of at least one bag B(x). Moreover, for every vertex v in V(G), the set of tree vertices whose bags contain v   induce a connected subtree of T. The width of T is the maximum size of its   bags minus one. The goal is to compute a tree decomposition of minimum width.","category":"page"},{"location":"pace_file_formats/","page":"PACE file formats","title":"PACE file formats","text":"We define the file format .td. As above, c lines are comments and can occur throughout the file. Instead of a p-line, we now expect a unique solution line s as the first non-comment line, which contains the string td, followed by the number N of bags of the tree decomposition, the width of the tree decomposition plus one (i.e., the largest bag size), as well as the number of vertices of the original input graph. The next non-comment lines we expect start with b and specify the contents of each bag; for example, b 4 3 4 6 7 specifies that bag number 4 contains the vertices 3, 4, 6, and 7 of the original graph. Bags may be empty. For every bag i, there must be exactly one line starting with b i. All remaining non-comment lines indicate an edge in the tree decomposition, so it must consist of two decimal integers from 1 and N where the first integer is smaller than the second, and the graph described this way must be a tree. For example, the following is a suboptimal tree decomposition of the path with four edges.","category":"page"},{"location":"pace_file_formats/","page":"PACE file formats","title":"PACE file formats","text":"c This file describes a tree decomposition with 4 bags, width 2, for a graph with 5 vertices\ns td 4 3 5\nb 1 1 2 3\nb 2 2 3 4\nb 3 3 4 5\nb 4\n1 2\n2 3\n2 4","category":"page"},{"location":"pace_file_formats/#Validity-checker","page":"PACE file formats","title":"Validity checker","text":"","category":"section"},{"location":"pace_file_formats/","page":"PACE file formats","title":"PACE file formats","text":"The validity checker at https://github.com/holgerdell/td-validate/ verifies that a given tree decomposition (specified in the .td file format) is indeed a valid tree decomposition of a given graph (specified in the .gr format). The validity checker will be used to evaluate whether your submitted implementation computed a correct tree decomposition.","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"library/internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Documentation for JunctionTrees.jl's internals.","category":"page"},{"location":"library/internals/#Index","page":"Internals","title":"Index","text":"","category":"section"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Pages = [\"internals.md\"]","category":"page"},{"location":"library/internals/#Factors","page":"Internals","title":"Factors","text":"","category":"section"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Modules = [JunctionTrees]\nPages = [\"factors.jl\"]\nPublic = false","category":"page"},{"location":"library/internals/#JunctionTrees._marg-NTuple{4, Any}","page":"Internals","title":"JunctionTrees._marg","text":"_marg(r_vals, ret_vars, Avals, dims) -> Factor\n\n\nPerformance critical code of the factor marginalization operation.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees._product-Tuple{Any, Any, Any}","page":"Internals","title":"JunctionTrees._product","text":"_product(A_vals_new, B_vals_new, C_vars) -> Factor{Float64}\n\n\nPerformance critical code of the factor product operation.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.my_indexin-Tuple{Any, Any}","page":"Internals","title":"JunctionTrees.my_indexin","text":"my_indexin(x, y) -> Any\n\n\nOptimzed version of the function indexin defined in Base.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Junction-tree-algorithm","page":"Internals","title":"Junction tree algorithm","text":"","category":"section"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Modules = [JunctionTrees]\nPages = [\"junction_tree_algorithm.jl\"]\nPublic = false","category":"page"},{"location":"library/internals/#Graphical-transformation","page":"Internals","title":"Graphical transformation","text":"","category":"section"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Modules = [JunctionTrees]\nPages = [\"graphical_transformation.jl\"]\nPublic = false","category":"page"},{"location":"library/internals/#JunctionTrees.add_edges!-Tuple{Any, Any}","page":"Internals","title":"JunctionTrees.add_edges!","text":"add_edges!(g, edges)\n\n\nConstruct the edges and store their sepset as an edge property.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.add_vertices!-Tuple{Any, Any}","page":"Internals","title":"JunctionTrees.add_vertices!","text":"add_vertices!(g, bags)\n\n\nAdd a vertex for each bag and initialize its properties.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.are_connected-Tuple{Any, Any, Any}","page":"Internals","title":"JunctionTrees.are_connected","text":"are_connected(g, v1, v2) -> Bool\n\n\nReturn whether vertices v1 and v2 are connected.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.calculate_sepset_key-Tuple{MetaGraphs.MetaGraph, Vector{Int64}, Any}","page":"Internals","title":"JunctionTrees.calculate_sepset_key","text":"calculate_sepset_key(g::MetaGraphs.MetaGraph, sepset::Vector{Int64}, cards) -> Tuple{Int64, Int64}\n\n\nCalculate the \"key\" of sepset based on:\n\nMass: The number of variables in sepset.\nCost: The product of the cardinality of each variable in sepset.\n\nThe number of variables in the sepset has higher priority than the prodcuct of their cardinality. The higher the mass, the lower the key. The lower the cost, the lower the key.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.calculate_var_key-Tuple{MetaGraphs.MetaGraph, Int64, Any}","page":"Internals","title":"JunctionTrees.calculate_var_key","text":"calculate_var_key(g::MetaGraphs.MetaGraph, v::Int64, cards) -> Tuple{Int64, Int64}\n\n\nCalculate the \"key\" of v based on:\n\nThe number of edges to be added if v's neighbors were to be connected.\nThe weight of v and its neighbors (also known as the induced bag).\n\nThe number of edges to be added has more priority than the wieight of the induced cluster. The lower the number of edges to be added, the lower the key. The lower the weight, the lower the key.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.connect_bags!-Tuple{MetaGraphs.MetaGraph, MetaGraphs.MetaGraph, Vector{Vector{Int64}}, Any}","page":"Internals","title":"JunctionTrees.connect_bags!","text":"connect_bags!(td::MetaGraphs.MetaGraph, mrf::MetaGraphs.MetaGraph, bags::Vector{Vector{Int64}}, cards)\n\n\nConnect the bags such that the running intersection propperty is satisfied.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.construct_td_graph-Tuple{Any, Any}","page":"Internals","title":"JunctionTrees.construct_td_graph","text":"construct_td_graph(mrf, cards) -> MetaGraphs.MetaGraph{Int64, Float64}\n\n\nTransform the given Markov random field into a junction tree. This implementation is based on \"Inference in Belief Networks: A Procedural Guide\" by Cecil Huang and Adnan Darwiche (1996) pg. 235.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.construct_td_graph-Tuple{String}","page":"Internals","title":"JunctionTrees.construct_td_graph","text":"construct_td_graph(td_filepath::String) -> Any\n\n\nConstruct a tree decomposition graph based on td_filepath.\n\nThe td_filepath file format is defined in: https://pacechallenge.org/2017/treewidth/.\n\nExample\n\ntd_filepath = \"../problems/Promedus_26/Promedus_26.td\"\ntd = computeMarginalsExpr(td_filepath)\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.cost-Tuple{MetaGraphs.MetaGraph, Vector{Int64}, Any}","page":"Internals","title":"JunctionTrees.cost","text":"cost(g::MetaGraphs.MetaGraph, sepset::Vector{Int64}, cards) -> Int64\n\n\nCompute the product of the cardinalities of bag constituent vars.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.count_edges_to_be_added-Tuple{MetaGraphs.MetaGraph, Int64}","page":"Internals","title":"JunctionTrees.count_edges_to_be_added","text":"count_edges_to_be_added(g::MetaGraphs.MetaGraph, v::Int64) -> Int64\n\n\nCompute the number of edges to be added to the graph if we choose to eliminate this vertex.\n\nArguments\n\ng::MetaGraph the graph to consider.\nv::Int64 the vertex to eliminate.\n\nReturn\n\ncount::Int64 number of edges to add in the graph g if v is eliminated.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.form_bags-Tuple{Any, Any}","page":"Internals","title":"JunctionTrees.form_bags","text":"form_bags(g, cards) -> Vector{Vector{Int64}}\n\n\nReturn the maximal cliques of g using the minfill heuristic. The maximal cliques of the triangulated graph correspond to the bags of the junction tree. This implementation is based on: \"Inference in Belief Networks: A Procedural Guide\" by Cecil Huang and Adnan Darwiche (1996) pg. 235. TODO: See https://matbesancon.xyz/post/2019-05-30-vertex-safe-removal/ to implement this function using a vertex-safe version of Graphs.jl. This would avoid having to bookkeep the node ids in the orginal graph after it is modified with rev_vertex!.\n\nBookkepping example for the paskin-example problem:\n\n| var to remove | vertices(g) | int2ext     | ext2int     |\n\n| 6             | 1 2 3 4 5 6 | 1 2 3 4 5 6 | 1 2 3 4 5 6 | | 4             | 1 2 3 4 5   | 1 2 3 4 5   | 1 2 3 4 5 0 | | 5             | 1 2 3 4     | 1 2 3 5     | 1 2 3 0 4 0 | | 2             | 1 2 3       | 1 2 3       | 1 2 3 0 0 0 | | 1             | 1 2         | 1 3         | 1 0 2 0 0 0 | | 3             | 1           | 3           | 0 0 1 0 0 0 | –––––––––––––––––––––––––––––-\n\nVariables preceded with _ use the internal variable indexation. Those without use the external/original variable indexation.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.get_induced_bag-Tuple{MetaGraphs.MetaGraph, Int64}","page":"Internals","title":"JunctionTrees.get_induced_bag","text":"get_induced_bag(g::MetaGraphs.MetaGraph, v::Int64) -> Any\n\n\nReturn the bag induced after removing v, i.e. the set of vars consisting of v and its neighbors.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.get_induced_bag_weight-Tuple{MetaGraphs.MetaGraph, Int64, Any}","page":"Internals","title":"JunctionTrees.get_induced_bag_weight","text":"get_induced_bag_weight(g::MetaGraphs.MetaGraph, v::Int64, cards) -> Int64\n\n\nCompute the weight of the bag consisting of v and its neighbors.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.is_maximal-Tuple{Any, Any}","page":"Internals","title":"JunctionTrees.is_maximal","text":"is_maximal(candidate_clique, cliques) -> Bool\n\n\nReturn whether clique is maximal in the clique_set\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.mass-Tuple{MetaGraphs.MetaGraph, Vector{Int64}}","page":"Internals","title":"JunctionTrees.mass","text":"mass(g::MetaGraphs.MetaGraph, sepset::Vector{Int64}) -> Int64\n\n\nReturn the number of vars in the sepset.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.preprocess_heap_elements-Tuple{MetaGraphs.MetaGraph, Any, Any, Any}","page":"Internals","title":"JunctionTrees.preprocess_heap_elements","text":"preprocess_heap_elements(g::MetaGraphs.MetaGraph, bag1, bag2, cards) -> NamedTuple{(:endpoints, :sepset, :key), _A} where _A<:Tuple{Tuple{Any, Any}, Any, Tuple{Int64, Int64}}\n\n\nCalculate the key for each element that will be inserted into the binary heap and wraps the edge, its sepset and the key into a tuple.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.weight-Tuple{Any, Vector{Int64}, Any}","page":"Internals","title":"JunctionTrees.weight","text":"weight(g, bag::Vector{Int64}, cards) -> Int64\n\n\nCompute the product of the cardinalities of bag constituent vars.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Initialization","page":"Internals","title":"Initialization","text":"","category":"section"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Modules = [JunctionTrees]\nPages = [\"initialization.jl\"]\nPublic = false","category":"page"},{"location":"library/internals/#JunctionTrees.assign_factors!-Tuple{Any, Any, Any}","page":"Internals","title":"JunctionTrees.assign_factors!","text":"assign_factors!(g, factors, smart_root_selection) -> JunctionTrees.Node\n\n\nAssign each factor to a cluster that covers its variables.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.compile_bag_potentials-Tuple{Any}","page":"Internals","title":"JunctionTrees.compile_bag_potentials","text":"compile_bag_potentials(g) -> Expr\n\n\nCompile each bag's potential into a Julia expression.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.initialize_td_graph!-Tuple{Any, Any, Any}","page":"Internals","title":"JunctionTrees.initialize_td_graph!","text":"initialize_td_graph!(g, factors, smart_root_selection) -> Tuple{JunctionTrees.Node, Expr}\n\n\nInitialize the td graph by assigning the different factors to one bag that covers its scope.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Observation-entry","page":"Internals","title":"Observation entry","text":"","category":"section"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Modules = [JunctionTrees]\nPages = [\"observation_entry.jl\"]\nPublic = false","category":"page"},{"location":"library/internals/#JunctionTrees.inject_redus-NTuple{4, Any}","page":"Internals","title":"JunctionTrees.inject_redus","text":"inject_redus(g, before_pass_pots, obsvars, obsvals) -> Expr\n\n\nInject a reduction expression to potentials that contain observed variables.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.inject_redus-NTuple{6, Any}","page":"Internals","title":"JunctionTrees.inject_redus","text":"inject_redus(td, before_pass_pots, before_pass_forward_pass, before_pass_backward_pass, obsvars, obsvals) -> Tuple{Expr, Expr, Expr}\n\n\nInject a reduction expression to potentials that contain observed variables.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.inject_redus_in_msgs-NTuple{4, Any}","page":"Internals","title":"JunctionTrees.inject_redus_in_msgs","text":"inject_redus_in_msgs(g, before_pass_msgs, obsvars, obsvals) -> Expr\n\n\nInject a reduction statement for each observed variable. Each reduction takes the observed variable and it's corresponding observed value. The reduction statements are introduced as late as possible, i.e. just before the observed variable is marginalized.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.inject_redus_in_pots-NTuple{4, Any}","page":"Internals","title":"JunctionTrees.inject_redus_in_pots","text":"inject_redus_in_pots(g, before_pass_pots, obsvars, obsvals) -> Expr\n\n\nInject a reduction statement for observed variables contained inside isolated bags. An isolated bag is a leaf bag connected to the rest of the tree via one empty sepset. Each reduction takes the observed variable and it's corresponding observed value. \n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Propagation","page":"Internals","title":"Propagation","text":"","category":"section"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Modules = [JunctionTrees]\nPages = [\"propagation.jl\"]\nPublic = false","category":"page"},{"location":"library/internals/#JunctionTrees.compile_backward_pass!-Tuple{Any, Any}","page":"Internals","title":"JunctionTrees.compile_backward_pass!","text":"compile_backward_pass!(g, root) -> Expr\n\n\nCompile the downstream messages.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.compile_forward_pass!-Tuple{Any, Any}","page":"Internals","title":"JunctionTrees.compile_forward_pass!","text":"compile_forward_pass!(g, root) -> Expr\n\n\nCompile the upstream messages.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.compile_message_propagation!-Tuple{Any, Any}","page":"Internals","title":"JunctionTrees.compile_message_propagation!","text":"compile_message_propagation!(g, root) -> Tuple{Expr, Expr}\n\n\nCompile the forward and backward passes of messages.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Marginalization","page":"Internals","title":"Marginalization","text":"","category":"section"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Modules = [JunctionTrees]\nPages = [\"marginalization.jl\"]\nPublic = false","category":"page"},{"location":"library/internals/#JunctionTrees.compile_unnormalized_marginals-Tuple{Any, Any, Any}","page":"Internals","title":"JunctionTrees.compile_unnormalized_marginals","text":"compile_unnormalized_marginals(g, nvars, partial_evaluation) -> Tuple{Expr, Expr, Expr}\n\n\nCompile marginalization statements for each variable from a sepset if possible and otherwise from a bag.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Normalization","page":"Internals","title":"Normalization","text":"","category":"section"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Modules = [JunctionTrees]\nPages = [\"normalization.jl\"]\nPublic = false","category":"page"},{"location":"library/internals/#JunctionTrees.compile_normalized_marginals-Tuple{Any}","page":"Internals","title":"JunctionTrees.compile_normalized_marginals","text":"compile_normalized_marginals(unnormalized_marginals) -> Expr\n\n\nCompile the normalized marginal expressions for each variable in the model.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Partial-Evaluation","page":"Internals","title":"Partial Evaluation","text":"","category":"section"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Modules = [JunctionTrees]\nPages = [\"partial_evaluation.jl\"]\nPublic = false","category":"page"},{"location":"library/internals/#JunctionTrees.mark_obsbags!-Tuple{Any, Any}","page":"Internals","title":"JunctionTrees.mark_obsbags!","text":"mark_obsbags!(g, obsvars)\n\n\nMark which nodes of g have at least one observed variable.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.partial_eval_analysis!-Tuple{Any}","page":"Internals","title":"JunctionTrees.partial_eval_analysis!","text":"partial_eval_analysis!(g)\n\n\nAnalyzes which messages can be computed during the compilation stage in the graph g.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.partial_eval_prop_update!-NTuple{5, Any}","page":"Internals","title":"JunctionTrees.partial_eval_prop_update!","text":"partial_eval_prop_update!(g, curr_node, prev_node, obs_bag_var, obs_var_marginalized)\n\n\nRecursive function that invalidates messages in the graph g that cannot be partially evaluated at compile time. This marking is done using MetaGraphs' properties for each edge in the graph.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.partial_evaluation-NTuple{4, Any}","page":"Internals","title":"JunctionTrees.partial_evaluation","text":"partial_evaluation(td, pots, forward_pass, backward_pass) -> Tuple{Expr, Expr}\n\n\nPartially evaluates messages of the propagation stage that do not depend on online observations.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.partially_evaluate-Tuple{Any, Any}","page":"Internals","title":"JunctionTrees.partially_evaluate","text":"partially_evaluate(g, before_pass_msgs) -> Expr\n\n\nPartially evaluate messages that do not depend on observed variables.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Abstract-Trees","page":"Internals","title":"Abstract Trees","text":"","category":"section"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Modules = [JunctionTrees]\nPages = [\"tree.jl\"]\nPublic = false","category":"page"},{"location":"library/internals/#JunctionTrees.Node","page":"Internals","title":"JunctionTrees.Node","text":"mutable struct Node{T}\n\nid::Any\nchildren::Array{JunctionTrees.Node{T}, 1} where T\nparent::JunctionTrees.Node\n\nTree node definition intended to be used with AbstractTrees.jl.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#JunctionTrees.addchild!-Tuple{Any, JunctionTrees.Node}","page":"Internals","title":"JunctionTrees.addchild!","text":"addchild!(id, parent::JunctionTrees.Node) -> JunctionTrees.Node\n\n\nAdd a child node with id id to parent.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.addchildren!-Tuple{Any, JunctionTrees.Node}","page":"Internals","title":"JunctionTrees.addchildren!","text":"addchildren!(ids, parent::JunctionTrees.Node) -> Any\n\n\nAdd several children with with ids ids to parent.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.convertToAbstractTree!","page":"Internals","title":"JunctionTrees.convertToAbstractTree!","text":"convertToAbstractTree!(g::MetaGraphs.MetaGraph, root::JunctionTrees.Node)\nconvertToAbstractTree!(g::MetaGraphs.MetaGraph, root::JunctionTrees.Node, parent::JunctionTrees.Node)\n\n\nConstruct a tree decomposition abstract tree based on the graph g using root as the root node.\n\nExample\n\nusing LightGraphs\n\ng = double_binary_tree(3)\nroot = Node(1)\nconvertToAbstractTree!(g, root)\nprint_tree(root)\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#Utils","page":"Internals","title":"Utils","text":"","category":"section"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Modules = [JunctionTrees]\nPages = [\"utils.jl\"]\nPublic = false","category":"page"},{"location":"library/internals/#JunctionTrees.construct_mrf_graph-Tuple{Any, Any}","page":"Internals","title":"JunctionTrees.construct_mrf_graph","text":"construct_mrf_graph(nvars, factors) -> MetaGraphs.MetaGraph\n\n\nConstruct a Markov random field graph with nvars variables and the cliques contained in factors.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.generate_function_expression-NTuple{4, Any}","page":"Internals","title":"JunctionTrees.generate_function_expression","text":"generate_function_expression(function_name, sig, variables, body) -> Expr\n\n\nGenerate a function expression using Julia's metaprogramming capabilities\n\nExample\n\nfunction_name = :foo\nsig = (Int, Float64, Int32)\nvariables = [:a, :q, :d]\nbody = :(a + q * d)\n\nex = generate_function_expression(function_name, sig, variables, body)\n\neval(ex)\n\nfoo(1, 2.0, Int32(3))\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.mark_leaves!-Tuple{MetaGraphs.MetaGraph}","page":"Internals","title":"JunctionTrees.mark_leaves!","text":"mark_leaves!(g::MetaGraphs.MetaGraph) -> Any\n\n\nMark which nodes of g correspond to leaves using a property.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.read_td_file-Tuple{String}","page":"Internals","title":"JunctionTrees.read_td_file","text":"read_td_file(td_filepath::String) -> Tuple{Int64, Int64, Int64, Vector{Vector{Int64}}, Vector{Vector{Int64}}}\n\n\nParse a tree decomposition instance described the PACE format.\n\nThe PACE file format is defined in: https://pacechallenge.org/2017/treewidth/\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.read_uai_evid_file-Tuple{String}","page":"Internals","title":"JunctionTrees.read_uai_evid_file","text":"read_uai_evid_file(uai_evid_filepath::String) -> Tuple{Union{Vector{Any}, Vector{Int64}}, Union{Vector{Any}, Vector{Int64}}}\n\n\nReturn the observed variables and values in uai_evid_filepath. If the passed file path is an empty string, return empty vectors.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#JunctionTrees.read_uai_file-Tuple{String}","page":"Internals","title":"JunctionTrees.read_uai_file","text":"read_uai_file(uai_filepath::String) -> Tuple{Int64, Vector{Int64}, Int64, Any}\n\n\nParse the problem instance found in uai_filepath defined in the UAI model format.\n\nThe UAI file format is defined in: https://personal.utdallas.edu/~vibhav.gogate/uai16-evaluation/uaiformat.html\n\n\n\n\n\n","category":"method"},{"location":"#JunctionTrees.jl","page":"Home","title":"JunctionTrees.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A metaprogramming-based implementation of the junction tree algorithm.","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Feature 1\nFeature 2","category":"page"},{"location":"library/public/#Public-Documentation","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Documentation for JunctionTrees.jl's public interface.","category":"page"},{"location":"library/public/#Index","page":"Public","title":"Index","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"library/public/#Public-Interface","page":"Public","title":"Public Interface","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"JunctionTrees\ncomputeMarginalsExpr\nFactor\nproduct\nmarg\nredu\nnorm\ngetGraph\nLastStage\nForwardPass\nBackwardPass\nJointMarginals\nUnnormalizedMarginals\nMarginals","category":"page"},{"location":"library/public/#JunctionTrees","page":"Public","title":"JunctionTrees","text":"Main module for JunctionTrees.jl – a Julia implementation of the junction tree algorithm.\n\nOne main function is exported from this module for public use:\n\ncomputeMarginalsExpr. Computes the posterior marginals using the\n\njunction tree algorithm given evidence.\n\nExports\n\nBackwardPass\nFactor\nForwardPass\nJointMarginals\nLastStage\nMarginals\nUnnormalizedMarginals\ncomputeMarginalsExpr\ngetGraph\nmarg\nnorm\nproduct\nredu\n\n\n\n\n\n","category":"module"},{"location":"library/public/#JunctionTrees.computeMarginalsExpr","page":"Public","title":"JunctionTrees.computeMarginalsExpr","text":"computeMarginalsExpr(uai_filepath::String; uai_evid_filepath, td_filepath, apply_partial_evaluation, last_stage, smart_root_selection) -> Expr\n\n\nReturn an expression containing the computations to compute the marginals of all the variables in the model using the junction tree algorithm.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#JunctionTrees.Factor","page":"Public","title":"JunctionTrees.Factor","text":"struct Factor{T, N}\n\nvars::Tuple{Vararg{Int64, N}} where N\nvals::Array\n\nA composite type that implements the factor datatype.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#JunctionTrees.product","page":"Public","title":"JunctionTrees.product","text":"product(A::Factor{T}, B::Factor{T}) -> Factor\n\n\nCompute a factor product of tables A and B.\n\nExamples\n\nA = Factor{Float64,2}((2, 1), [0.5 0.1 0.03; 0.8 0.0 0.9])\nB = Factor{Float64,2}((3, 2), [0.5 0.1; 0.7 0.2])\nC = product(A, B)\n\n\n\n\n\nproduct(F::Factor{T}...) -> Factor\n\n\nCompute a factor product of an arbitrary number of factor arguments.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#JunctionTrees.marg","page":"Public","title":"JunctionTrees.marg","text":"marg(A::Factor{T, ND}, V::Tuple{Vararg{Int64, N}} where N) -> Factor\n\n\nSum out the variables in V from factor A.\n\nExamples\n\nA = Factor{Float64,3}((3, 2, 1), cat([0.25 0.08; 0.05 0.0; 0.15 0.09],\n                                     [0.35 0.16; 0.07 0.0; 0.21 0.18], dims=3))\nV = [1]\nB = marg(A, V)\n\nA = Factor{Float64,3}((2, 7, 1), cat([1 2; 3 4;  5  6],\n                                     [7 8; 9 10; 11 12], dims=3))\nV = [7]\nB = marg(A, V)\n\n\n\n\n\nmarg(A::Factor, V::Int64...) -> Factor\n\n\nSum out an aribitrary number of variables from factor A.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#JunctionTrees.redu","page":"Public","title":"JunctionTrees.redu","text":"redu(A::Factor{T}, vars::Tuple, vals::Tuple) -> Factor\n\n\nReduce/invalidate all entries that are not consitent with the evidence.\n\nExamples\n\nA = Factor{Float64,3}((1, 2, 3), cat([0.25 0.08; 0.05 0.0; 0.15 0.09],\n                                     [0.35 0.16; 0.07 0.0; 0.21 0.18], dims=3))\nvars = (1,3)\nvals = (1,1)\nB = redu(A, vars, vals)\n\n\n\n\n\n","category":"function"},{"location":"library/public/#JunctionTrees.norm","page":"Public","title":"JunctionTrees.norm","text":"norm(A::Factor) -> Factor\n\n\nNormalize the values in Factor A such that all probabilities lie between 0 and 1.\n\nExamples\n\nA = Factor([2, 1], [1.0 2.0 3.0; 4.0 5.0 6.0])\nB = norm(A)\n\n\n\n\n\n","category":"function"},{"location":"library/public/#JunctionTrees.getGraph","page":"Public","title":"JunctionTrees.getGraph","text":"getGraph() -> Any\n\n\nReturn the current graph.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#JunctionTrees.LastStage","page":"Public","title":"JunctionTrees.LastStage","text":"Enumerated type used to select up to which stage an expression of the junction tree algorithm should be returned.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#JunctionTrees.ForwardPass","page":"Public","title":"JunctionTrees.ForwardPass","text":"Return an expression up to and including the forward pass.\n\n\n\n\n\n","category":"constant"},{"location":"library/public/#JunctionTrees.BackwardPass","page":"Public","title":"JunctionTrees.BackwardPass","text":"Return an expression up to and including the backward pass.\n\n\n\n\n\n","category":"constant"},{"location":"library/public/#JunctionTrees.JointMarginals","page":"Public","title":"JunctionTrees.JointMarginals","text":"Return an expression that computes the cluster joint marginals.\n\n\n\n\n\n","category":"constant"},{"location":"library/public/#JunctionTrees.UnnormalizedMarginals","page":"Public","title":"JunctionTrees.UnnormalizedMarginals","text":"Return an expression that computes the joint marginals.\n\n\n\n\n\n","category":"constant"},{"location":"library/public/#JunctionTrees.Marginals","page":"Public","title":"JunctionTrees.Marginals","text":"Return an expression that computes the posterior marginals.\n\n\n\n\n\n","category":"constant"}]
}
